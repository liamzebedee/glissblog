{"content":"# A dumb primer on recursive ZK proofs \n\nHow do I understand recursive ZK proofs? / A better way.\n\nBy **Liam Zebedee ([@liamzebedee](https://twitter.com/liamzebedee))** and **XYZ**\n\n**Acknowledgements**. This came directly out of convos with Lord from Biblioteca, Francesco from Apibara, Guiltygyoza, in the entire StarkNet hacker house at ETHLisbon 2022. Thank you to them, and the organisers of that house.\n\nPS: Don't feel scared by the length - the sections are designed to be skippable.\n\n## Part 1: memoization.\n\nIn JavaScript, we have a common optimization pattern called [memoization](https://en.wikipedia.org/wiki/Memoization). For those not familiar, memoization is kind of like caching the results of calling a function, so when you call it again with the same inputs, you get the result from the cache.\n\nMemoization is usually implemented as a higher-order function, meaning it takes a function as input and returns another function. Here's an idiot's implementation of `memoize(x)` in Python:\n\n```py\ncache = {}\ndef memoize(f):\n    # The memoized version of f(x).\n    def f2(x):\n        if not x in cache:\n            cache[x] = f(x)\n        return cache[x]\n    return f2\n```\n\n**Learning**: memoization is wrapping a function with a results cache.\n\n## Part 2: ZK proofs - a practical walkthrough in Cairo.\n\nNow let's recap ZK proofs - a shorthand for ZK-STARK's and ZK-SNARK's. \n\nA ZK proof is a way to prove computation, in such a way that verifying that proof takes less time than running it. For a program that takes $N$ computational steps, we can prove it and verify that proof in $O(log^2 N)$ steps using STARK's - an exponential speedup. I've written a fairly good summary of this on [this Twitter thread](https://twitter.com/liamzebedee/status/1516241618919374851)). \n\nWhat does ZK proofing look like? Usually you write a \"provable\" program using a language like [Cairo](https://www.cairo-lang.org/), which compiles to bytecode, which is executed in a VM that generates a \"trace\" - basically, a dump of the values of the VM's CPU registers over time. This trace is then proven using a prover (see [Giza](https://github.com/maxgillett/giza), an open-source one I worked on), and out the other side, you get a binary blob. \n\nFor example:\n\n```cairo!\n# program.cairo\nfunc fib(n) {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    return fib(n-1) + fib(n-2)\n}\n```\n\n\nCompile, run and generate the trace:\n\n```shell!\n# Compile.\ncairo-compile ./program.cairo --output ./program.json\n\n# Run.\ncairo-run --program=program.json --layout=all --memory_file=memory.bin --trace_file=trace.bin\n```\n\nNow prove the trace:\n\n```shell!\ngiza prove --trace=trace.bin --memory=memory.bin --program=program.json --output=proof.bin\n```\n\nThe proof is generated as a file, `proof.bin`. The proving step will take longer than running the program, but the verification will be much shorter. We can verify it like so:\n\n```shell!\ngiza verify --proof=proof.bin\n```\n\nNow, how do we know what we're actually verifying? Obviously it could be a proof of anything. In some ZK systems like [circom](https://github.com/iden3/circom), we have two separate compilation outputs - the proving circuit and the verification circuit, the latter of which we would use to authoritively verify a program run. In Starkware, they have a primitive higher up the stack called the \"bootloader\", which a **known program** that will execute any program given to it. \n\nHow do we know we're running the bootloader? The program hash is exposed as public memory input into the program run, and because it's public memory, we can access it as part of the proof in `proof.bin`. \n\nThis is what it looks like, conceptually:\n\n```cairo!\nfunc bootloader(code: felt*, program_hash: felt, input: felt*) {\n    # communicate with the verifier that we are executing this program.\n    assert hash(code) == program_hash\n    # write program_hash to public_memory\n    \n    # execute\n    push input to memory\n    jump code\n    # equivalent to f(x), where f=code, x=input\n}\n```\n\nTo illustrate how this works, we might have `bootloader.py` which will setup the bootloader to run our program. Then proving looks the same:\n\n```py!\n# This will write the program.json and the input data (fib(20)) to the bootloader's memory slot.\npython3 bootloader.py load --program program.json --entrypoint \"fib(20)\" --output-memory memory.bin\n\n# Now we run using the bootloader, which will run fib(20).\ncairo-run --program=bootloader.json --layout=all --memory_file=memory.bin --trace_file=trace.bin\n\n# Same steps for prove.\ngiza prove --trace=trace.bin --memory=memory.bin --program=program.json --output=proof.bin\n\n# Verify.\n# a. Verify we are running program.json, by checking the program_hash == H(program.json) inside proof.bin.\npython3 bootloader.py verify-invocation --proof proof.bin --program program.json --entrypoint \"fib(20)\"\n# b. Verify the proof.\ngiza verify --proof=proof.bin\n```\n\nAnd that's basically the full runthrough of a real ZK-STARK system, minus the bootloader.\n\n**Learning**: We write a program in Cairo, compile it to bytecode, run it to generate a trace, prove the trace, and then verify the proof. To verify what we're verifying, we use something called a bootloader, which communicates the program hash in the proof data via public memory.\n\n## Part 3: Recursive ZK proofs.\n\nSo what the fuck is recursive ZK proofing? \n\nIt's alien technology, that's what it is. We like communicating with aliens. But like most aliens, you can't understand what the fuck they're talking about at first.\n\nThe first lesson - recursion in proofing does not look like recursion **in any other language you're familiar with**. There is no \"call stack\" that is growing in size. There is no \"calling the same function\". So I think the analogy is completely stupid, tbh.\n\nRecursive proofing is this idea of \"verifying proofs within proofs\". Basically, you have `giza prove`, but this program is actually implemented in Cairo. So it's an API you can call within your ZK programs, which allows you to verify proofs from other program invocations. \n\nThis is fucking magic. Because you can verify a proof that verifies other proofs, which verifies other proofs...and eventually you get a single 20kB file which succinctly verifies an entire blockchain's history. See [ZeroSync for a genuine attempt to do this on Bitcoin](https://github.com/lucidLuckylee/zerosync). \n\n**But**, it's a terrible analogy. The recursion occurs conceptually, not inside of the programming language. It actually just looks like invoking a pure function. \n\nThe only language that implements recursive proofing right now is Mina. I've [written an example which uses recursion in ZK proofs](https://gist.github.com/liamzebedee/8d2efbb105d3b474dbe752d526cc9d27), and this is what it looks like using their API:\n\n```ts\n# From https://gist.github.com/liamzebedee/8d2efbb105d3b474dbe752d526cc9d27\n\n        transfer: {\n            privateInputs: [SelfProof],\n\n            method(t1: Transaction, t0: SelfProof<Transaction>) {\n                // Verify the state at t=0 was computed correctly.\n                t0.verify();\n\n                // State: utxo signature validation.\n                const t1_sighash = t1.sighash();\n                const msg = [t1_sighash];\n```\n\nt0 is a `SelfProof`, basically a class which is a proof. `verify()` is a method. Does that look like recursion to you? No. \n\n**Learning**: Recursive ZK proofs are extremely powerful. But the recursion occurs conceptually, not like it looks like in normal programming (no call stacks, no calling the same function).\n\n\n## Part 4: A better analogy for recursive proofs.\n\nSo here's the meat - I think memoization is a much better way to imagine recursion in ZK proofing. Coming back to the beginning of our article, this is `memoize(x)`:\n\n```py\ncache = {}\ndef memoize(f):\n    # The memoized version of f(x).\n    def f2(x):\n        if not x in cache:\n            cache[x] = f(x)\n        return cache[x]\n    return f2\n```\n\nThe funny thing is, a ZK proof is kind of like a secure cache. If I compute `fib(n=100)`, and give you a number, you can't trust me without running the `fib(n=100)` which is $O(N)$ steps. But what if I prove `fib(n=100)` and give you the proof? Then it costs you $O(log^2 N)$ steps to trust me, by verifying the proof. \n\nWhat might this look like applied to our memoize helper?\n\n```py\ncache = {}\ndef memoize(f):\n    # The \"securely\" memoized version of f(x).\n    def f2(x):\n        if not x in cache:\n            cache[x] = prove(f(x))\n        return verify(cache[x])\n    return f2\n```\n\n**Learning**: Another way to understand recursive proofs is through the idea of a \"secure cache\". The cache values are checked automatically using the `verify` function from Starkware.\n\n\n## Part 5: A better API for recursive proofs.\n\nRecursion is a fitting analogy conceptually, but when programming, we might think of a more ergonomic API design. What if we could annotate any function as `provable`? e.g.\n\n```cairo!\n# program2.cairo\n\n#[provable]\nfunc fib(n) {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    return fib(n-1) + fib(n-2)\n}\n```\n\nAnd in other places, we could interact as so:\n\n```cairo!\n# program2.cairo\n\nfunc run_1() {\n    proof = fib.prove()\n}\n\nfunc run_2(proof: felt*) {    \n    // Verify the proof.\n    val = fib.verify(proof)\n}\n```\n\nBut why have `prove`/`verify` splattered throughout our code? Could we go more ergonomic? Why not have this built into the runner? Maybe we could have a shared `cache` for all function invocations, and the runtime would automatically memoize and check the cache. \n\nHere's how this might work:\n\n * a public area of memory dedicated to the cache.\n * cairo-run and giza are modified to accept \"secure cache entries\" - proofs.\n * the Cairo runtime automatically rewrites functions annotated as \"provable\" to check this cache for results, thus removing the need for the programmer to write \"verify\".\n\nThe potential workflow:\n\n```cairo!\n# program3.cairo\n\n#[provable]\nfunc fib(n) {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    return fib(n-1) + fib(n-2)\n}\n\nfunc main1() {\n    val = fib(100)\n}\n\nfunc main2() {\n    val = fib(100)\n}\n```\n\nThere are no verify API calls here. The verification occurs automatically inside the Cairo runtime - `cairo-run`. We begin by running the program:\n\n```shell!\n# Compile.\ncairo-compile ./program3.cairo --output ./program3.json\n\n# Run main1.\ncairo-run --program=program3.json --entrypoint \"main1\" --layout=all --memory_file=memory.bin --trace_file=trace1.bin --cache_file=cache1.json\n\n# Prove main1.\ngiza prove --trace=trace1.bin --memory=memory.bin --program=program3.json --output=proof1.bin\n```\n\nThis might generate `cache1.json` looking like:\n\n```json\n[\n    {\n        \"name\": \"fib\",\n        \"code\": \"00a00e0fd0bca...\",\n        \"hash\": \"010e0f0dd0bca...\",\n        \"cache\": {\n            \"100\": \"PROOF_DATA\"\n        }\n    }\n]\n```\n\nThe second invocation, `main2`, we run the same function but we supply the cache of function invocations. \n\n```shell!\n# Run main1.\ncairo-run --program=program3.json --entrypoint \"main2\" --layout=all --memory_file=memory.bin --trace_file=trace2.bin --cache_file=cache1.json\n\n# Prove main1.\ngiza prove --trace=trace2.bin --memory=memory.bin --program=program3.json --output=proof1.bin\n```\n\nAnd there you have it - an API for recursive proofs that doesn't litter our code. Comparing this against the Mina code, where we have to be **manually passing around proofs** and intermixing our code with these verify functions, this is much more ergonomic. `SelfProof<Transaction>.verify()` vs. `#[provable]`. It feels very clean.\n"}